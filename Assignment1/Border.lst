------- FILE Border.s LEVEL 1 PASS 2
      1  107a ????						; in this test program we experiemented with creating the border for our game. 
      2  107a ????						; we stored the address of the graphic we want to use in the correct screen memory address
      3  107a ????
      4  107a ????				      processor	6502
      5  107a ????						; Memory locations
      6  107a ????
      7  107a ????	       ff d2	   CHROUT     =	$ffd2	; KERNAL routine to output a character
      8  107a ????	       00 00	   SCREEN_POS_LO =	$00	; Low byte of screen memory address
      9  107a ????	       00 01	   SCREEN_POS_HI =	$01	; High byte of screen memory address
     10  107a ????	       00 02	   COLOR_POS_LO =	$02	; Low byte of color memory address
     11  107a ????	       00 03	   COLOR_POS_HI =	$03	; High byte of color memory address
     12  107a ????	       1e 00	   SCREEN_START =	$1E00	; Start of screen memory in VIC-20
     13  107a ????	       00 16	   SCREEN_WIDTH =	22	; VIC-20 screen width (22 columns)
     14  107a ????	       00 17	   SCREEN_HEIGHT =	23	; VIC-20 screen height (23 rows)
     15  107a ????	       96 00	   COLOR_START =	$9600	; Color memory start	 
     16  1001					      org	$1001	; Starting memory location
     17  1001
     18  1001							; BASIC stub
     19  1001		       0b 10		      dc.w	nextstmt
     20  1003		       0a 00		      dc.w	10
     21  1005		       9e 34 31 30*	      dc.b	$9e, "4109", 0
     22  100b				   nextstmt
     23  100b		       00 00		      dc.w	0
     24  100d
     25  100d				   START
     26  100d		       a9 93		      lda	#$93
     27  100f		       20 d2 ff 	      jsr	CHROUT	; Clear the screen
     28  1012
     29  1012
     30  1012							; Set up the top border
     31  1012		       a9 df		      lda	#$DF	; Character to represent the border
     32  1014		       a2 16		      ldx	#SCREEN_WIDTH	; Number of characters to print
     33  1016		       a0 00		      ldy	#0	; Start at the first screen memory location
     34  1018
     35  1018				   draw_top_border
     36  1018
     37  1018		       a9 df		      lda	#$DF
     38  101a		       99 00 1e 	      sta	SCREEN_START,y	; Store at the location
     39  101d		       a9 00		      lda	#$00	; Black color for the memory address
     40  101f		       99 00 96 	      sta	COLOR_START,y
     41  1022		       c8		      iny		; Increment Y to move to the next screen position
     42  1023		       ca		      dex		; Decrement X (count down the number of characters)
     43  1024		       d0 f2		      bne	draw_top_border	; Check if the x is 0
     44  1026
     45  1026							;Draw the side borders, taking into account 44 addresses per row
     46  1026		       a2 16		      ldx	#SCREEN_HEIGHT-1	; Number of visible rows (23 rows for VIC-20)
     47  1028		       a9 00		      lda	#<SCREEN_START	; Load the low byte of the screen start address
     48  102a		       85 00		      sta	SCREEN_POS_LO
     49  102c		       a9 1e		      lda	#>SCREEN_START	; Load the high byte of the screen start address
     50  102e		       85 01		      sta	SCREEN_POS_HI
     51  1030		       a9 00		      lda	#<COLOR_START	; Load the low byte of the color start address
     52  1032		       85 02		      sta	COLOR_POS_LO
     53  1034		       a9 96		      lda	#>COLOR_START	; Load the high byte of the color start address
     54  1036		       85 03		      sta	COLOR_POS_HI
     55  1038							;Loop to draw the side borders
     56  1038				   draw_side_borders
     57  1038
     58  1038		       a9 df		      lda	#$DF	; Character to represent the side border
     59  103a
     60  103a							; Draw the left border at the start of the row
     61  103a		       a0 00		      ldy	#0
     62  103c		       91 00		      sta	(SCREEN_POS_LO),y	; Store border character at the leftmost column
     63  103e		       a9 00		      lda	#$00	; Set color to black
     64  1040		       91 02		      sta	(COLOR_POS_LO),y	; Store color at the 
     65  1042
     66  1042		       a9 df		      lda	#$DF	; Character to represent the side border
     67  1044
     68  1044							; Draw the right border, offset by 21 visible columns 
     69  1044		       a0 15		      ldy	#SCREEN_WIDTH-1	; Set Y to 21 which is the last right column
     70  1046		       91 00		      sta	(SCREEN_POS_LO),y	; Store border character 
     71  1048		       a9 00		      lda	#$00	; Set color to black
     72  104a		       91 02		      sta	(COLOR_POS_LO),y	; Store color 
     73  104c
     74  104c							; Increment the screen position by SCREEN_WIDTH so we can go to the next row
     75  104c		       18		      clc		; Clear carry for addition
     76  104d		       a5 00		      lda	SCREEN_POS_LO
     77  104f		       69 16		      adc	#SCREEN_WIDTH	; Add SCREEN_WIDTH to the low byte
     78  1051		       85 00		      sta	SCREEN_POS_LO	; Store back the result
     79  1053		       90 02		      bcc	skip_high_increment	; If carry is clear, skip incrementing the high byte
     80  1055		       e6 01		      inc	SCREEN_POS_HI	; Otherwise, increment the high byte
     81  1057
     82  1057				   skip_high_increment
     83  1057							; Increment the color memory position as well
     84  1057		       18		      clc		; Clear carry for addition
     85  1058		       a5 02		      lda	COLOR_POS_LO
     86  105a		       69 16		      adc	#SCREEN_WIDTH	; Add SCREEN_WIDTH to the low byte of color memory
     87  105c		       85 02		      sta	COLOR_POS_LO	; Store back the result
     88  105e		       90 02		      bcc	skip_color_high_inc	; If carry is clear, skip incrementing the high byte
     89  1060		       e6 03		      inc	COLOR_POS_HI	; Otherwise, increment the high byte of color memory
     90  1062
     91  1062				   skip_color_high_inc
     92  1062		       ca		      dex		; Decrement row counter
     93  1063		       d0 d3		      bne	draw_side_borders	; Repeat the loop for each row
     94  1065
     95  1065							; Draw the bottom border
     96  1065				   draw_bottom_border
     97  1065		       a9 df		      lda	#$DF	; Character to represent the border
     98  1067		       a2 16		      ldx	#SCREEN_WIDTH	; Number of characters to print in the bottom row
     99  1069		       a0 00		      ldy	#0	; Start from the leftmost column of the last row
    100  106b
    101  106b				   draw_bottom_loop
    102  106b		       a9 df		      lda	#$DF
    103  106d		       91 00		      sta	(SCREEN_POS_LO),y	; Store the border character in each column
    104  106f		       a9 00		      lda	#$00	; Set color to black
    105  1071		       91 02		      sta	(COLOR_POS_LO),y	; Store color in the same column
    106  1073
    107  1073		       c8		      iny		; Increment Y to move to the next column
    108  1074		       ca		      dex		; Decrement the X counter
    109  1075		       d0 f4		      bne	draw_bottom_loop	; Continue until X = 0`
    110  1077
    111  1077				   infinite_loop
    112  1077		       4c 77 10 	      jmp	infinite_loop
